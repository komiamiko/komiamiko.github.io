---
layout: post
title: "Future Gardens"
date: 2020-05-07 20:00
categories: games
---

{::options parse_block_html="true" /}

# Future Gardens
{: #app-section}

{% include collapser.markdown %}

<div>

<div class="no-js">
This app requires JavaScript to run.
</div>

<div id="fgardens-browser-notice">
The game needs to check browser compatibility. <br/>
If you don't see a result here and the page already loaded some time ago, there was likely a catastrophic failure.
</div>

## Writing your own story
{: #writing-own-story}

{% include collapser.markdown %}

<div>

Diversity blossoms around you in town, <br/>
Artists, enchanters, architects and more. <br/>
Each person a role that could have been you, <br/>
But plants were your calling, it's just what you do.

You're not the first to grow and study plants, <br/>
But these are your gardens, and they are your home. <br/>
Your unique powers can take you further than others. <br/>
Where will this take you?
Only time will tell.

In your gardens are plants never seen before. <br/>
A <span id="fgardens-inject-plant-name-010010-0"></span>,
a <span id="fgardens-inject-plant-name-010010-1"></span>. <br/>
First named by you, with flowery whimsy. <br/>
This is your story, that you write as you go.

</div>

## It begins with a plant
{: #fgardens-section-first}

{% include collapser.markdown %}

<div id="fgardens-container-group-0">

</div>

## The future is now
{: #future-now}

{% include collapser.markdown %}

<div>

Every day, your gardens grow more, <br/>
Bountiful nature and plants to explore. <br/>
Even so, your gardens grow slow. <br/>
Sometimes you wish it were not so.

Legends tell of a regretful fool, <br/>
Who once chose wrong and wished to go back. <br/>
What's done is done, the past set in stone, <br/>
But the future is still open, an opportunity to make your own.

Your abilities give you new options here, <br/>
With much effort bringing the far future near. <br/>
A lifetime's collection condensed into one, <br/>
A goal that would otherwise never be done.

On this new quest you look forward again, <br/>
A future of futures, a most distant door. <br/>
Reaching your goal, you rebuild again, <br/>
Finding yourself in your future gardens once more.

</div>

## Your future gardens
{: #fgardens-section-second}

{% include collapser.markdown %}

<div id="fgardens-container-group-1">

</div>

## A new theory, a new model
{: #models-theories}

{% include collapser.markdown %}

<div>

Theories, you're no stranger to them, <br/>
What one fails to capture, another amends. <br/>
Your current model falls rather short, <br/>
Some plants you can't name, no means to the end.

With research, you can create a new model, <br/>
A new comprehension to help you build more. <br/>
For that research, you need some plant samples. <br/>
Lucky for you, the minimum is ample.

</div>

## A comfortable place to study
{: #fgardens-section-challenge}

{% include collapser.markdown %}

<div id="fgardens-container-models">

<div id="fgardens-model-z010011">

### Structural Decomposition

Need 1 <span id="fgardens-inject-plant-name-010011-0"></span>
and 1 <span id="fgardens-inject-plant-name-010011-1"></span>.

Reduces the initial threshold for a future collapse from 2<sup>22</sup> to 2<sup>16</sup>.

<button type="button" onmousedown="gardens.extSendTakeModelZ10()" id="fgardens-model-button-z010011"></button>

</div>

<div id="fgardens-model-z010012">

### Unnamed02

Need 1 <span id="fgardens-inject-plant-name-010012-0"></span>
and 1 <span id="fgardens-inject-plant-name-010012-1"></span>.

???

<button type="button" onmousedown="gardens.extSendTakeModelZ20()" id="fgardens-model-button-z010012"></button>

</div>

<div id="fgardens-model-z010013">

### Unnamed03

Need 1 <span id="fgardens-inject-plant-name-010013-0"></span>
and 1 <span id="fgardens-inject-plant-name-010013-1"></span>.

???

<button type="button" onmousedown="gardens.extSendTakeModelZ30()" id="fgardens-model-button-z010013"></button>

</div>

<div id="fgardens-model-z011010">

### Unnamed10

Need 1 <span id="fgardens-inject-plant-name-011010-0"></span>
and 1 <span id="fgardens-inject-plant-name-011010-1"></span>.

???

<button type="button" onmousedown="gardens.extSendTakeModelZ01()" id="fgardens-model-button-z011010"></button>

</div>

</div>

## A challenge for yourself
{: #challenge-yourself}

{% include collapser.markdown %}

<div>

One day, you thought of a new kind of spell. <br/>
You tried it at home, but it did nothing and fell. <br/>
Even far from your gardens, every time it would fail, <br/>
As if across worlds they held fast to your tail.

You would need to destroy your lower gardens, <br/>
And abide by the strict terms of the spell, <br/>
But if you could return and finish casting, <br/>
The reward would be great, you can already tell.

</div>

## Never, yet eventual
{: #never-eventual}

{% include collapser.markdown %}

<div>

Every day, no matter how high you build, <br/>
The sky remains above you still. <br/>
A height you reach eventually, <br/>
But in your lifetime would never see.

Futures of futures and stacking some more, <br/>
A thousand lifetimes, it's still not enough. <br/>
Out of reach for your simple steps, <br/>
Truly, reaching this milestone is tough.

Even so, you would not lose hope. <br/>
That garden is eventual, different from never. <br/>
With new models, patience, and care, <br/>
It will not be out of reach forever.

</div>

## Distanced a world away
{: #fgardens-section-third}

{% include collapser.markdown %}

<div id="fgardens-container-group-2">

</div>

## If things had gone differently
{: #different-timelines}

{% include collapser.markdown %}

<div>

You think about how things could have gone, <br/>
Not different choices, but if the rules were different. <br/>
A new kind of magic will let you do just that, <br/>
To give up this timeline, and in a new world start again.

You would lose all that you built up so far, <br/>
Your mana, your gardens, all you did create. <br/>
Never to return, this world becomes history, <br/>
Your memories and knowledge are all you can keep. <br/>
Even your models won't work where you'll go, <br/>
With new rules, new plants and challenges await.

</div>

## Specks in the past
{: #fgardens-section-history}

{% include collapser.markdown %}

<div>

<div id="fgardens-container-history">
</div>

<div id="fgardens-container-reset" style="display:none;">

<div id="fgardens-reset-key-display">
</div>

<label for="fgardens-reset-key-entry">Please enter the numbers above to confirm you want to reset</label>
<input type="text" id="fgardens-reset-key-entry" name="fgardens-reset-key-entry">

</div>

<button type="button" onmousedown="gardens.extSendResetGame()">Reset game with new seed</button>

<label for="fgardens-settings-seed">World seed</label>
<input type="text" id="fgardens-settings-seed" name="fgardens-settings-seed">
<button type="button" onmousedown="gardens.extSendNewSeedCasual()">Generate a new seed</button>

Any seed is fine for casual play.
For more competitive use, the game creator only officially endorses seeds meeting certain requirements, which the game will indicate are "verified".
Verified seeds come with some gameplay adjustments, such as only allowing the minimum number of clicks.
In a setting where multiple people are to use the same seed, it is recommended to use the name of the event or group in place of the individual player's name.

Generation of this seed may take some time depending on your computer.
When the seed is ready, it will be entered into the seed box.

<label for="fgardens-settings-name">Your name</label>
<input type="text" id="fgardens-settings-name" name="fgardens-settings-name">
<button type="button" onmousedown="gardens.extSendNewSeedVerified()">Generate verified seed</button>

<div id="fgardens-settings-verified-seed-display">
</div>

</div>

## Marking your steps
{: #marking-steps}

{% include collapser.markdown %}

<div>

Coming this far, you've made some good memories. <br/>
Recounting your tales, you begin new research. <br/>
Searching for patterns, stripping away details, <br/>
Seeing, across worlds, what never changes.

Your mana goes up, counting one two, <br/>
Jumping to infinity, your future gardens, <br/>
Counting up again, to a larger infinity, <br/>
Vaulting toward your eventual gardens.

Plants out of the picture, just symbols on parchment, <br/>
You explore the infinities for mathematical interest, <br/>
Creating systematic names for all of your gardens, <br/>
All that you have, and all that you'll ever have.

You study infinities, detached from your gardens, <br/>
Their regular properties, where higher to go. <br/>
The magic to get there far eludes you, <br/>
But at least your scheme can map it out.

</div>

## How far you've come
{: #fgardens-section-ordinal-counter}

{% include collapser.markdown %}

<div>

<div id="fgardens-container-ordinal-counter" class="ordinal-display-large">
</div>

When you're ready, you can reveal the ordinals that you've been collecting all along.

<label for="fgardens-display-kind">Text display mode:</label>
<select name="fgardens-display-kind" id="fgardens-display-kind-selector">
  <option value="fancy" selected="selected">Flowery names</option>
  <option value="ordinal">Ordinals</option>
</select>

</div>

</div>

# Developer commentary
{: #dev-commentary}

{% include collapser.markdown %}

<div>

## Inspiration
{: #inspiration}

{% include collapser.markdown %}

<div>

### Prestige in incremental games
{: #prestige-incremental}

{% include collapser.markdown %}

<div>

Incremental games, otherwise referred to as clicker games or idle games, are characterized by a large range of numbers for you to climb, lots of waiting, and possibly clicking.
They also commonly have some form of a game mechanic called "prestige".

As commonly presented to the player:

> Once you reach a certain point in the game, you can reset your game but gain a permanent boost, which helps you progress faster and climb higher in the ladder in future runs.

First of all, you aren't truly resetting your game.
Generally you do give up some kind of progress or resource, but you gain something new in the process.

</div>

### Exploring prestige with matchstick diagrams
{: #matchstick-exploration}

{% include collapser.markdown %}

<div>

If we mark the times where we reach milestones in the game leading up to the first prestige, or even as we obtain individual units of game resource or currency, it looks something like this.

{% include light_box_begin.markdown %}

![Matchstick diagram of omega. Looks like the rungs of an infinite ladder, extending off into the distance.](/assets/ordinal-images/matchstick-omega.svg)

{% include light_box_end.markdown %}

*This "matchstick diagram" and all other matchstick diagrams in this post were taken from [Madore's website](http://www.madore.org/~david/weblog/d.2011-09-18.1939.nombres-ordinaux-intro.html). I did not make them, and I am using them here for educational purposes.*

It gets progressively faster until you reach the point in the game where you can prestige.
So far, not very interesting.

Later runs are faster than the first, and we start to gain prestige bonuses faster.
In many incremental games, this prestige is even measured by another number, much like the basic resource or currency of the game.
If we mark the times that we prestige, they form another accelerating series, which quite possibly converges if the game is eventually won or there is yet another layer of prestige after this one.

{% include light_box_begin.markdown %}

![Matchstick diagram of omega^2. Looks like a series of infinite ladders, where the horizon at the end of each ladder leads into the start of the next, and the series as a whole tapers off into the distance.](/assets/ordinal-images/matchstick-omega-2.svg)

{% include light_box_end.markdown %}

Oops! We accidentally invented the matchstick diagram.

</div>

### Ordinal model of prestige
{: #ordinal-prestige}

{% include collapser.markdown %}

<div>

I already teased it earlier, but ordinals provide a natural way to measure prestige.
You can read more about ordinals elsewhere, but here, I only provide a brief introduction.

Ordinals extend the natural numbers.
Under the Von Neumann definition of ordinals, every ordinal is a set which contains all the ordinals that are less than it and only those ordinals.
*0* is the empty set since it is the smallest ordinal, *1* is *{0}*, *2* is *{0, 1}*, and so on.
*ω* then is precisely the set of all natural numbers: *{0, 1, 2, 3, ...}*
By definition, all the natural numbers, since they are included in *ω*, are less than *ω*.

In the game, we count up at first in the natural numbers: *0, 1, 2, 3, ...*
Once we reach some arbitrary large number *N*, we are able to prestige, which moves us to *ω*.
We would have a single *ω*, representing a point of prestige, and no large number *N* tacked onto it, which would represent the basic currency.
According to the ordinals, *ω* is larger than any possible *N*.
Does this make sense?
Well, the first prestige is the eventual goal of any first run.
Regardless of how long that run takes or how high you ascend there, every possible run ends up at that same prestige point.
In a similar manner, *ω* is the limit of the sequence *0, 1, 2, 3, ...*.
If you follow that sequence, or any increasing sequence of numbers, at infinity, you eventually reach *ω*.

In the second run, we count up with *ω + N*.
Then, at the second prestige, we move to *ω2*.
This counts up as *ω2 + N*, eventually reaching *ω3*, and so on.
If there is another layer of prestige after the first layer, the eventual goal of all runs would be the first prestige of the second prestige layer.
In a similar manner, the limit of the sequence *0, ω, ω2, ω3, ...* is *ω<sup>2</sup>*.
Thus, *ω<sup>2</sup>* is the unit of the second prestige layer.

</div>

### Prestige in batches
{: #prestige-batch}

{% include collapser.markdown %}

<div>

A lot of incremental games won't just give you a single *ω* after collecting enough *1*s, but rather, allow you to redeem multiple *ω* at once.
Notably, if you get far enough in your first layer run, you can redeem more *ω* at once than if you just got barely far enough to redeem any at all.
This would, at first glance, appear to break our ordinal model of prestige.

Skipping ordinals doesn't matter.
What's important that characterizes *ω* as *ω* is that you had to trade in your *1* progression to get a *ω*, which preserves *ω* and higher currencies.
Given the choice between *ωN* and *M*, you would certainly take *ωN*, unless you could trade in *M* immediately for at least *ωN*.

Fractional units work fine too.
You can read about [surreal numbers](https://en.wikipedia.org/wiki/Surreal_number) if you're interested.
It's the most natural way to combine infinite ordinals and real number arithmetic, though beware, to achieve that, we need to give up normal ordinal arithmetic.
In the surreals, *1 + ω = ω + 1* just as real number addition is commutative, but this is not true for ordinals.

</div>

### *ω<sup>ω</sup>* and prestige
{: #omega-omega-prestige}

{% include collapser.markdown %}

<div>

At this point I am obligated to inform you that **ordinals are meaningless for ascending**.
No matter where you start, no matter how you count, there will always be an infinite number of ordinals above.
You can ascend in any silly and arbitrary sequence and get an infinite sequence of ordinals.
The true utility of ordinals is in descending.
The ordinal *3* says you can take only 3 steps down.
The ordinal *ω* says the number of steps down you can take is unbounded, but once you take your first step, you lock yourself in to a finite number of steps remaining.
The ordinal *ω2* says once you take your first step, you either lock yourself into a finite number of steps remaining total, or you lock yourself into a finite number of steps before you must take a step that locks yourself into having a finite number of steps remaining total.
Descriptions of this form become cumbersomely long with higher ordinals, but remember, that is what the ordinal really means.

All incremental games I have seen so far use a finite number of prestige layers.
I have never seen a game that lets you reach *ω<sup>ω</sup>*, which is the limit of the sequence *1, ω, ω<sup>2</sup>, ω<sup>3</sup>...*.

One issue that arises in determining a game's ordinal is what counts as a prestige.
If a game uses 3 different currencies before the first of what it calls a prestige, has it attained *ω<sup>3</sup>* or only *ω*?
It depends on how those currencies behave.
If gaining the second currency is the eventual goal of collecting the first and gaining the third currency is the eventual goal of collecting the second, then it does attain *ω<sup>3</sup>*.
If the currencies all go up together rather than each building on the previous one, then just one number is sufficient to measure the progress, and it attains only *ω*.
This example with *ω<sup>3</sup>* may sound silly, but what we really wanted to discuss was *ω<sup>ω</sup>*.
There is not fundamentally a difference between a game that uses *ω* different currencies leading up to a single layer of prestige, and a game that uses *ω* layers of prestige leading up to a final ultimate layer of prestige.
For both, the unit of the largest layer of prestige is *ω<sup>ω</sup>*.

You may have noticed there is an unnatural offset in the ordinals I used.
For a game that has one layer of currency then one layer of prestige, this is 2 layers total, so shouldn't it be *ω<sup>2</sup>*, not *ω*?
That is correct.
Ordinals conventionally measure not what a system does obtain, but what the system cannot.
In this case, what *ω<sup>2</sup>* represents is the smallest ordinal that the game will never reach.
The examples before of *ω* layers leading up to a final single layer are measured by *ω<sup>ω + 1</sup>*, which is the smallest ordinal they will never reach.

You may have thought of the case where a system goes exactly up to and including some ordinal *α*, and no further, and that in this case perhaps it is easier to associate the system with *α*.
Actually there is no issue assigning the system a least ordinal that it cannot reach - this ordinal is simply *α + 1*.
The convention that systems are measured by the least ordinal it cannot reach is fully capable of handling these cases,
and if you recall the Von Neumann definition of ordinals, every [downward closed](https://en.wikipedia.org/wiki/Upper_set) set of ordinals is itself an ordinal, so it is quite universal.
If you have the choice to use one or the other, choose to measure a system by the smallest ordinal it cannot reach, for consistency reasons.

</div>

### Higher ordinals and the game
{: #higher-ordinals-game}

{% include collapser.markdown %}

<div>

I wanted to create a game that could reach *ω<sup>ω</sup>* or higher.
Originally, I wanted to shoot as high as possible, and I started setting up a regular hierarchy using Buchholz's *ψ* for the ordinal notation.
However, that conflicts with my more important goal, which is to get people to be aware of the ordinals and appreciate just how large they are.
To make ordinals appear large, you shouldn't let the player climb to large ordinals - quite the opposite, you need to make apparently small ordinals hard to reach.
I don't think the slow-growing hierarchy is sufficient to give players a sense of scale, since numbers don't go up.
The Hardy hierarchy is alright, so I decided to go for some variant of it as the underlying hierarchy.

I made a decision in planning for the game to go up to *ω<sup>ω<sup>2</sup></sup>*, though the end of content happens already well before that.
The hierarchy was carefully designed so it'd appear to go faster up to *ω<sup>ω</sup>*, but after that, progress would appear to slow down, and further progress would seem difficult.
It's not because of some hardcoded brake in the game.
In fact, undoubtedly, your ordinal is getting larger at an accelerating rate.
It's just that humans reframe the scale to be focused on milestones, and if we just look at the next major ordinals coming after *ω<sup>ω</sup>*, such as *ω<sup>ω + 1</sup>* and *ω<sup>ω2</sup>*, then the game does appear to slow down a lot.

I did also include a "models" game mechanic, which in some sense is a kind of ultimate prestige layer,
however, I don't think that classification is actually accurate, since there are a finite number of models and you will reach significantly higher ordinals than ever before once the last model is attained.
I chose to structure the game this way so players would have enough time to properly enjoy each tier, without making the next tier inaccessible.

I also set aside my desire for great elegance and something that just naturally works.
Instead, I set out to create a fun game experience.
While a lot of content is created programmatically combining a regular structure and random elements, I also have made a significant number of hand tweaks to make it better.

</div>

</div>

## Making the game
{: #making-of-game}

{% include collapser.markdown %}

<div>

### Plant sequences
{: #making-of-plants}

{% include collapser.markdown %}

<div>

You've probably caught on to the oddly regular sequence of costs of plants.
Where does this come from?
It's actually [Sylvester's sequence](https://en.wikipedia.org/wiki/Sylvester%27s_sequence),
and before I can explain why it made a great fit for this, I first need to explain ordinary differential equations.

Let's say we have some kind of resource and an autoclicker for it, with the ability to spend the resource to gain more of the autoclicker.
At perfect (*100%*) "efficiency", *1* unit of resource buys *1* autoclicker.
If purchases are done optimally, this results in exponential growth - no surprise there.
What happens when the "efficiency" is less than *1* though?
At *50%* efficiency, we're taking the square root - *16* units of resources invested only gives *4* autoclickers.
This clearly isn't capable of exponential growth, but just how fast does it grow?
We can figure out by solving the first order ordinary differential equation (ODE) *f'(t) = f(t)<sup>1/2</sup>* with initial value *f(0) = 1*, and turns out it's proportional to *t<sup>2</sup>*.
This makes sense - it means *f'(t)* is proportional to *t*, which correctly is of the same order as *f(t)<sup>1/2</sup> = t<sup>2 × (1/2)</sup> = t*.
In general, if the efficiency is *E*, then the ODE looks like *f'(t) = f(t)<sup>E</sup>*, and the resulting growth rate is *f(t) ~ t<sup>1/(1 - E)</sup>*.
As expected, the closer you get to perfect efficiency, the faster the growth.

The first part of making our incremental system is choosing the multipliers, or equivalently, choosing the efficiency.
Upgrades come in discrete packets that each have a cost *C*, so to make the efficiency not perfect, we should choose a multiplier *M* less than *C*.
In the end, I chose the curve *M = C - sqrt(C) + 1* because it was dead simple and it has desirable characteristics.
Simple is good here because it prevents people from accusing me of hand massaging the curves.
This starts with pretty bad efficiency - *M = 1.59* at *C = 2*, and *M = 2.27* at *C = 3* - but importantly, as we go up, the efficiency converges to *1*.
This seems like a good design decision, as higher *C* upgrades appear less often, so it feels like they should be closer to perfect to help "fill in the gaps".

The final piece that makes it all work is blending all the factors together, and this is where Sylvester's sequence comes in.
Denote Sylvester's sequence as *S<sub>0</sub> = 2, S<sub>1</sub> = 3, S<sub>2</sub> = 7, ...*.
They have a really neat property that *1/S<sub>0</sub> + 1/S<sub>1</sub> + ...* converges to *1* from below as fast as possible.
We use *1/S<sub>n</sub>* as the weight when we distribute - the *2* factor gets *1/2* of its strength, the *3* factor gets *1/3* of its strength, the *7* factor gets *1/7* of its strength, and so on.
This way, *1* unit total of strength can be said to be distributed evenly over the infinite sequence.
This distributing makes it look a bit bad mannered - each time you buy a *2<sup>k</sup>*, it only multiplies your income by *1.26*, and when you buy a *3<sup>k</sup>*, it only multiplies your income by *1.31*.
Even so, the overall efficiency of this whole series with the weighted distribution is about *0.72719*, meaning the growth exponent is about *3.6656*.
This is actually quite generous for a first run!

Besides having nice math properties, using Sylvester's sequence as the bases also makes for naturally interesting spacing of milestones.
It's not quite repetitive, things don't line up, but there's no randomness and no fine tuning, just some simple math.

Only the first *5* values of Sylvester's sequence (*2, 3, 7, 43, 1807*) are actually used, since further ones would contribute so little to the multiplier as to be nearly useless.
The remaining *5* values have been very slightly increased to compensate, so the efficiency overall is still the same as if the sequence wasn't truncated.

I just need to point out one more thing for this story to be complete.
As you'd notice if you played the game for a while, having higher ordinals makes lower tiers go by faster.
This is because I added a few more terms to the equation so that the efficiency can increase when you have some higher ordinals.
It was a bit difficult balancing my desire as a game creator to fine tune the equation and my more mathematical desire for a simple and "natural" equation, but in the end I think I struck a good compromise.
It still has the spirit of the original equation and has a gentle curve which increases in efficiency as you feed it more multipliers.

</div>

### Models in the game
{: #making-of-models}

{% include collapser.markdown %}

<div>

#### Purpose of models
{: #models-purpose}

{% include collapser.markdown %}

<div>

Models exist to divide the game experience into distinct tiers of play,
each meant to present something new and exciting, make the player feel powerful,
and simultaneously make their efforts feel inconsequential in the face of that tier's goal.

</div>

#### Up to Structural Decomposition
{: #to-model-01}

{% include collapser.markdown %}

<div>

The first tier, naturally, is focused on a single garden.
Without ever explicitly telling the player what mana or plants are, it gives sufficient time to figure it out by experimenting.
I wouldn't want to hold a player in the gardens for too long and have them lose interest due to an apparent lack of depth in the game or too high difficulty.
However, it is important as part of the setup to make reaching *ω* feel difficult.
This is their first goal, and they get a peek of what comes next.

Within this first tier, reaching *ω<sup>2</sup>* is practically impossible.
The largest *ω* batch you need to redeem at once is *31*, with power *6955.923259...* at *ω*, and with *3147* current *ω* mana.
This yields an offset of *+38.226240...*, which far overtakes the multiplier.
If you'll trust my calculation, it would take about *2<sup>24.5</sup>* times longer to reach *ω<sup>2</sup>* compared to *ω*.

With the first model, the base cost is reduced to a lower *2<sup>16</sup>*.
While this is a significant improvement in the constants, it does nothing about the fast growth of the requirements - the mana cost to reach *ω<sup>N</sup>* still scales with *2 ↑↑ N*.
Higher gardens are still out of reach, but importantly, the player is now able to reach *ω<sup>2</sup>* to obtain the next model.

</div>

#### Up to ???
{: #to-model-02}

{% include collapser.markdown %}

<div>



</div>

</div>

### Challenge system
{: #making-of-challenges}

{% include collapser.markdown %}

<div>

The challenge system was one of the hardest parts of the game to implement.
It was the one thing that kept gameplay interesting while climbing an ordinal ladder.
As you'd notice if you reached that point in the game, every challenge is randomly generated,
and it's diverse enough that you can tell they aren't all premade and handcrafted.

Without going too much into the gritty details, I can at least describe the basic infrastructure.
Every challenge is generated initially as a kind of special low level program, a little higher than assembly.
This program has complexity limits, and is divided into 3 sections - retrieving data, manipulating data, and applying rules.
All data is strongly typed, and there are additional restrictions on what can be done.
Still, there's enough options here to ensure diversity.
If a program fails the checks and we can't trivially fix it, we just generate a new one and try again.
After a program passes type checking, it then gets transpiled into an abstract syntax tree (AST).
Finally, we perform optimizations.
While the optimization engine does occasionally allow stupid things to slip through, it will at least do a lot of basic things like boolean logic simplification.

There's one more exotic optimization done.
Since challenges are only allowed to affect lower tiers, this means some ordinal predicates will always be true or false.
The game can generally figure out when this happens, but it's not perfect.

Having the challenges' difficulty be programmatically judged as well is unreasonable to ask.
As the best compromise I can offer, all challenges have the same bounty.
Some will just be easier to complete than others.
Some end up being impossibly difficult.
That's just how it is when you aren't handcrafting all the challenges.

</div>

### Fastforwarding and offline progress
{: #making-of-fastforward}

{% include collapser.markdown %}

<div>

Consider this scenario, which sounds plausibly like it comes from an actual incremental game:

> You start with 0 clips, 1 worker bot, and 1 factory.
> Clips increase at a rate of *#bots*, bots increase at a rate of *#factory*, and factories increase at a rate of *log2(#bots)*.

Don't mind that a continuous domain doesn't actually make sense at these small numbers.
When the numbers get large enough, it's about the same as if it was continuous.

After 1 hour (3600 seconds), we'll have 166 billion clips, 145 million bots, and 86 thousand factories.
That sounds entirely reasonable, and it's what you'd expect to happen.
Unfortunately what a lot of games do is just extrapolate based on the rate at the last time step.
In this case, it would say the rates are *(1, 1, 0)*, so after 1 hour you should have *(0, 1, 1) + 3600 × (1, 1, 0) = (3600, 3601, 1)* of the appropriate resources.

"Can't you just take more steps?"

Taking more steps would indeed improve the accuracy, but it isn't very efficient.
What I just described is the [Euler method](https://en.wikipedia.org/wiki/Euler_method),
which is a first order method, meaning that if your time step is *h*, then the global truncation error, which is how far off you are after stepping all the way to a fixed target time, is proportional to *h*, or *O(h)* as we say.
If you use twice as many samples, the error only gets cut in half.

[RK4 (explicit Runge-Kutta 4)](https://en.wikipedia.org/wiki/Runge-Kutta) is what I would be talking about here, but actually the ODE model does not apply very well for this game.
The hierarchy is rather discretized and there's a lot of jumps.
Instead the time step is done using an event-based method.
The game looks for the next major milestone, such as gaining 1 unit of the next higher currency, and estimates the time until that event would be reached.
If the event takes longer to reach than the time step, we look for the next smaller milestone and try again with that.
If the event can be reached in that timespan, the game jumps to that event and the time taken is deducted.
There's also some more clever logic to estimate the most of the highest currency that can be gained within the timespan, and in one jump fastforward to that much gained, so it's not a pure event-based method like I described, but at its core it is still event-based.
This event-based system ensures the passage of time is accurate whether you're watching the game or offline for a long time.

</div>

</div>

</div>

<script id="chromajs-script" src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>
<script src="/assets/js/future_gardens.js"></script>
